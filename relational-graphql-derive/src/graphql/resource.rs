//! Derive macro for the `Resource` trait.

use super::graphql_path;
use crate::helpers::{parse_docs, AttrParser};
use convert_case::{Case, Casing};
use itertools::{Either, Itertools};
use proc_macro2::{Span, TokenStream};
use quote::{format_ident, quote};
use syn::{
    Attribute, Data, DataStruct, DeriveInput, Expr, Field, Fields, GenericArgument, Ident,
    PathArguments, Type, Visibility,
};

/// Derive a `Resource` instance for a struct.
pub fn derive(
    DeriveInput {
        vis,
        ident,
        generics,
        data,
        attrs,
    }: DeriveInput,
) -> TokenStream {
    if !generics.params.is_empty() {
        panic!("Resource cannot be derived on generic types");
    }
    match data {
        Data::Struct(s) => generate_struct(s, vis, ident, attrs),
        _ => panic!("Resource can only be derived for structs"),
    }
}

fn generate_struct(
    s: DataStruct,
    vis: Visibility,
    name: Ident,
    attrs: Vec<Attribute>,
) -> TokenStream {
    let graphql = graphql_path();
    let p = AttrParser::new("resource");
    let name_str = name.to_string();

    // The visibiltiy of exported fields in the macro generated by this module.
    let export: Visibility = syn::parse2(match &vis {
        // If the original struct is private to its scope, export the generated items to that scope
        // but no farther.
        Visibility::Inherited => quote!(pub(super)),
        // Otherwise use the explicity visibility from the original struct.
        _ => quote!(#vis),
    })
    .unwrap();
    // Field metas are generated in a nested module, so they need to be exported one additional
    // level to be visible in the parent module.
    let field_export: Visibility = syn::parse2(match &vis {
        Visibility::Inherited => quote!(pub(in super::super)),
        _ => quote!(#vis),
    })
    .unwrap();

    // Get fields, filtering out skipped ones.
    let Fields::Named(fields) = s.fields else {
        panic!("Resource fields must be named");
    };
    let (skipped, fields): (Vec<_>, Vec<_>) = fields.named.into_iter().partition_map(|f| {
        if let Some(default) = skipped_field_default(&p, &f) {
            Either::Left((f, default))
        } else {
            Either::Right(f)
        }
    });

    // Get the plural name for this struct. If it is given explicitly via the `plural` attribute we
    // will use that; otherwise just add an `s`.
    let plural_name = p
        .get_arg(&attrs, "plural")
        .unwrap_or_else(|| format_ident!("{}s", name));
    let plural_name_str = plural_name.to_string();

    // Derive a name for the module that will contain the generated items;
    let mod_name = p
        .get_arg(&attrs, "module")
        .unwrap_or_else(|| default_mod_name(&name));

    // Get the documentation on this struct. We will need to add this to the generated `#[Object]`
    // impl so that it shows up in the exported schema.
    let doc = parse_docs(&attrs);

    // Derive names for the various structs we are going to create.
    let input_name = format_ident!("{}Input", name);
    let pred_name = format_ident!("{}Predicate", name);
    let has_name = format_ident!("{}Has", name);
    let relation_pred_name = format_ident!("{}Predicate", plural_name);
    let quant_name = format_ident!("Quantified{}Predicate", name);

    // Create documentation for each of the structs.
    let input_doc = format!("An input to create a new {}.", name);
    let has_doc = format!("A predicate on fields of {}.", name);
    let pred_doc = format!("A predicate used to filter {}.", plural_name);
    let quant_doc = format!(
        "A predicate which must match a certain quantity of {}.",
        plural_name
    );
    let relation_pred_doc = format!("A predicate used to filter collections of {}.", plural_name);

    // Get the ID field.
    let id_field = fields
        .iter()
        .find(|f| field_is_id(&p, f))
        .expect("Resource must have ID field");
    let id_name = field_meta_name(
        id_field
            .ident
            .as_ref()
            .expect("Resource fields must be named"),
    );

    // If this struct has a _primary field_, it gets a couple of extra predicate options. In
    // addition to filtering by applying a predicate to its fields, you can implicitly filter based
    // on the primary field, which leads to shorter, more readable queries. In particular, you can
    // say, e.g. `state CA` instead of `state with abbreviation CA`.
    let primary_field = fields.iter().find(|f| p.has_bool(&f.attrs, "primary"));
    // The `is` predicate based on the primary field.
    let is_primary = primary_field.as_ref().map(|f| {
        let ty = &f.ty;
        quote! {
            /// Filter by value.
            Is(<#ty as Type>::Predicate),
        }
    });
    // The `includes` relation predicate, filtering a collection based on whether or not it contains
    // any items with the given value for their primary field.
    let includes_primary = primary_field.as_ref().map(|f| {
        let ty = &f.ty;
        quote! {
            /// Matches if the collection includes the specified value.
            Includes(Value<#ty>),
        }
    });

    // Generate marker types to hold metadata for each field.
    let field_metas = fields
        .iter()
        .map(|f| generate_field_meta(&field_export, &name, f));
    let field_meta_impls = fields
        .iter()
        .map(|f| generate_field_meta_impl(&p, &name, &plural_name, &pred_name, f, primary_field));

    // Generate code to reconstruct each field from a builder.
    let field_builders = fields
        .iter()
        .map(|f| generate_field_builder(&p, &name, &plural_name, f));

    // Generate code to populate skipped fields with default values during building.
    let skipped_field_builders = skipped.iter().map(|(f, default)| {
        let name = f.ident.as_ref().expect("Resource fields must be named");
        quote!(#name: #default,)
    });

    // Generate code to visit each field of this struct.
    let field_visitors = fields
        .iter()
        .filter_map(|f| {
            if field_relation(&p, &name, &plural_name, f).is_some() {
                // This is a relation, not a field.
                None
            } else {
                Some(generate_field_visitor(f))
            }
        })
        .collect::<Vec<_>>();
    let input_field_visitors = fields
        .iter()
        .filter_map(|f| {
            if field_is_input(&p, &name, &plural_name, f) {
                Some(generate_field_visitor(f))
            } else {
                None
            }
        })
        .collect::<Vec<_>>();
    let relation_visitors = fields
        .iter()
        .filter_map(|f| field_relation(&p, &name, &plural_name, f).map(generate_relation_visitor))
        .collect::<Vec<_>>();

    // Count the number of fields of each type.
    let num_fields = format_ident!("U{}", field_visitors.len());
    let num_input_fields = format_ident!("U{}", input_field_visitors.len());
    let num_relations = format_ident!("U{}", relation_visitors.len());

    // Generate an input field for each required field of this struct.
    let input_fields = fields
        .iter()
        .filter_map(|f| generate_input_field(&p, &name, &plural_name, &export, f));

    // Generate predicates for each field of this struct.
    let pred_fields = fields
        .iter()
        .map(|f| generate_predicate_field(&p, &name, &plural_name, f));

    // Generate builder methods for each field of this struct.
    let has_builder_fields = fields
        .iter()
        .map(|f| generate_has_builder_field(&p, &name, &plural_name, &export, f));

    // Generate resolvers for each field.
    let resolvers = fields
        .iter()
        .map(|f| generate_resolver(&p, &name, &plural_name, f));

    quote! {
        #vis mod #mod_name {
            use super::*;
            use #graphql::{
                async_graphql, connection::{self, Connection},
                backend::{Connection as _, Cursor, DataSource, PageRequest},
                type_system::{
                    typenum, Array, Builder, BuildError, Field, FieldVisitor, InputField,
                    InputFieldVisitor, ManyToManyRelation, ManyToOneRelation, Predicate, Relation,
                    RelationVisitor, RelationPredicate, RelationPredicateCompiler, Resource,
                    ResourceBuilder, ResourceInput, ResourcePredicate, Type, Value, Visitor,
                },
                Context, D, EmptyFields, InputObject, Object, OneofObject, Result,
            };

            #[doc = #doc]
            #[Object]
            impl #name {
                #(#resolvers)*
            }

            // The field metas are the only types generated here which can't be accessed through a
            // projection of the original type. (Contrast with, e.g., `<#name as Type>::Predicate`
            // to unambiguously reference the predicate type.) To prevent their names from colliding
            // with the names of other resources, we generate them in a nested module.
            #[doc = "Metadata about fields of "]
            #[doc = #name_str]
            #export mod fields {
                #(#field_metas)*
            }
            #(#field_meta_impls)*

            #[doc = #input_doc]
            #[derive(Clone, Debug, InputObject)]
            #export struct #input_name {
                #(#input_fields)*
            }

            impl ResourceInput<#name> for #input_name {}

            #[doc = #has_doc]
            #[derive(Clone, Debug, Default, InputObject)]
            #export struct #has_name {
                #(#pred_fields)*
            }

            impl #has_name {
                #(#has_builder_fields)*
            }

            #[doc = #pred_doc]
            #[derive(Clone, Debug, OneofObject)]
            #export enum #pred_name {
                /// Filter by fields.
                Has(Box<#has_name>),
                #is_primary
            }

            impl From<#has_name> for #pred_name {
                fn from(has: #has_name) -> Self {
                    Self::Has(Box::new(has))
                }
            }

            impl Predicate<#name> for #pred_name {}
            impl ResourcePredicate<#name> for #pred_name {}

            #[doc = #quant_doc]
            #[derive(Clone, Debug, InputObject)]
            #export struct #quant_name {
                /// The minimum or maximum number of items which must match.
                quantity: usize,
                /// The predicate to match against specific items.
                predicate: #pred_name,
            }

            #[doc = #relation_pred_doc]
            #[derive(Clone, Debug, OneofObject)]
            #export enum #relation_pred_name {
                /// Matches if at least some number of items in the collection match a predicate.
                AtLeast(#quant_name),
                /// Matches if at most some number of items in the collection match a predicate.
                AtMost(#quant_name),
                /// Matches if at any items in the collection match a predicate.
                Any(#pred_name),
                /// Matches if all items in the collection match a predicate.
                All(#pred_name),
                /// Matches if no items in the collection match a predicate.
                None(#pred_name),
                #includes_primary
            }

            impl RelationPredicate<#name> for #relation_pred_name {
                fn compile<C: RelationPredicateCompiler<#name>>(self, compiler: C) -> C::Result {
                    unimplemented!("relation predicate compilation")
                }
            }

            impl #name {
                /// Filter this resource by its fields.
                #export fn has() -> #has_name {
                    Default::default()
                }
            }

            impl Type for #name {
                type Predicate = #pred_name;

                // When referred to as an input to another resource, this resource is referenced by
                // ID, not included by value.
                type Input = Id;

                const NAME: &'static str = #name_str;
                const PLURAL_NAME: &'static str = #plural_name_str;

                fn build<B: Builder<Self>>(builder: B) -> Result<Self, B::Error> {
                    Self::build_resource(builder.resource())
                }

                fn describe<V: Visitor<Self>>(visitor: V) -> V::Output {
                    visitor.resource()
                }
            }

            impl Resource for #name {
                type NumFields = typenum::#num_fields;
                type NumInputFields = typenum::#num_input_fields;
                type NumRelations = typenum::#num_relations;

                type Id = fields::#id_name;

                type ResourcePredicate = #pred_name;
                type RelationPredicate = #relation_pred_name;

                type ResourceInput = #input_name;

                fn build_resource<B: ResourceBuilder<Self>>(builder: B) -> Result<Self, B::Error> {
                    Ok(Self {
                        #(#field_builders)*
                        #(#skipped_field_builders)*
                    })
                }

                fn describe_fields<V: FieldVisitor<Self>>(
                    visitor: &mut V,
                ) -> Array<V::Output, Self::NumFields> {
                    [#(#field_visitors),*].into()
                }

                fn describe_input_fields<V: InputFieldVisitor<Self>>(
                    visitor: &mut V,
                ) -> Array<V::Output, Self::NumInputFields> {
                    [#(#input_field_visitors),*].into()
                }

                fn describe_relations<V: RelationVisitor<Self>>(
                    visitor: &mut V,
                ) -> Array<V::Output, Self::NumRelations> {
                    [#(#relation_visitors),*].into()
                }
            }
        }
    }
}

#[derive(Clone, Debug)]
struct Relation {
    name: Ident,
    arity: RelationArity,
    target: Ident,
    inverse: Type,
}

#[derive(Clone, Copy, Debug)]
enum RelationArity {
    ManyToMany,
    ManyToOne,
}

fn generate_field_meta(vis: &Visibility, resource: &Ident, f: &Field) -> TokenStream {
    let name = field_meta_name(f.ident.as_ref().expect("Resource fields must be named"));
    let doc = format!("Metadata about the field {resource}::{name}.");
    quote! {
        #[doc = #doc]
        #[derive(Clone, Copy, Debug)]
        #vis struct #name;
    }
}

fn generate_field_meta_impl(
    p: &AttrParser,
    resource: &Ident,
    plural_resource: &Ident,
    pred_name: &Ident,
    f: &Field,
    primary_field: Option<&Field>,
) -> TokenStream {
    let name = f.ident.as_ref().expect("Resource fields must be named");
    let meta_name = field_meta_name(name);
    let name_str = name.to_string();
    let ty = &f.ty;
    if let Some(Relation {
        arity,
        inverse,
        target,
        ..
    }) = field_relation(p, resource, plural_resource, f)
    {
        let arity_trait = match arity {
            RelationArity::ManyToMany => quote!(ManyToManyRelation),
            RelationArity::ManyToOne => quote!(ManyToOneRelation),
        };
        let visit = match arity {
            RelationArity::ManyToMany => quote!(visit_many_to_many),
            RelationArity::ManyToOne => quote!(visit_many_to_one),
        };
        let get_primary = primary_field.map(|_| {
            // A relation can never be the primary field, so if we try to get the predicate on this
            // relation from a predicate on the primary field, we simply return [`None`].
            quote!(#pred_name::Is(_) => None,)
        });
        quote! {
            impl Relation for fields::#meta_name {
                type Owner = #resource;
                type Target = #target;
                const NAME: &'static str = #name_str;

                fn visit<V: RelationVisitor<Self::Owner>>(visitor: &mut V) -> V::Output {
                    visitor.#visit::<Self>()
                }

                fn get_predicate(
                    predicate: &#pred_name,
                ) -> Option<&<Self::Target as Resource>::RelationPredicate> {
                    match predicate {
                        #pred_name::Has(has) => {
                            has.#name.as_ref()
                        }
                        #get_primary
                    }
                }

                fn get_predicate_mut(
                    predicate: &mut #pred_name,
                ) -> Option<&mut <Self::Target as Resource>::RelationPredicate> {
                    match predicate {
                        #pred_name::Has(has) => {
                            has.#name.as_mut()
                        }
                        #get_primary
                    }
                }

                fn take_predicate(
                    predicate: &mut #pred_name,
                ) -> Option<<Self::Target as Resource>::RelationPredicate> {
                    match predicate {
                        #pred_name::Has(has) => {
                            has.#name.take()
                        }
                        #get_primary
                    }
                }
            }

            impl #arity_trait for fields::#meta_name {
                type Inverse = #inverse;
            }
        }
    } else {
        let get_primary = primary_field.map(|primary| {
            if f.ident == primary.ident {
                quote!(#pred_name::Is(f) => Some(f),)
            } else {
                quote!(#pred_name::Is(_) => None,)
            }
        });
        let take_primary = primary_field.map(|primary| {
            if f.ident == primary.ident {
                quote!(#pred_name::Is(_) => {
                    // If we take the primary predicate from an `Is` variant, there are no
                    // predicates left, but `Is` requires exactly one. Thus, the predicate changes
                    // to a `Has` variant with no fields.
                    let #pred_name::Is(f) = std::mem::replace(
                        predicate, #pred_name::Has(Default::default()),
                    ) else {
                        unreachable!();
                    };
                    Some(f)
                })
            } else {
                quote!(#pred_name::Is(_) => None,)
            }
        });
        let input = if field_is_input(p, resource, plural_resource, f) {
            Some(quote! {
                impl InputField for fields::#meta_name {
                    fn get_input(
                        input: &<Self::Resource as Resource>::ResourceInput,
                    ) -> &<Self::Type as Type>::Input {
                        &input.#name
                    }
                }
            })
        } else {
            None
        };

        quote! {
            impl Field for fields::#meta_name {
                type Type = #ty;
                type Resource = #resource;
                const NAME: &'static str = #name_str;

                fn get(resource: &Self::Resource) -> &Self::Type {
                    &resource.#name
                }

                fn get_predicate(
                    predicate: &#pred_name,
                ) -> Option<&<Self::Type as Type>::Predicate> {
                    match predicate {
                        #pred_name::Has(has) => {
                            has.#name.as_ref()
                        }
                        #get_primary
                    }
                }

                fn get_predicate_mut(
                    predicate: &mut #pred_name,
                ) -> Option<&mut <Self::Type as Type>::Predicate> {
                    match predicate {
                        #pred_name::Has(has) => {
                            has.#name.as_mut()
                        }
                        #get_primary
                    }
                }

                fn take_predicate(
                    predicate: &mut #pred_name,
                ) -> Option<<Self::Type as Type>::Predicate> {
                    match predicate {
                        #pred_name::Has(has) => {
                            has.#name.take()
                        }
                        #take_primary
                    }
                }
            }

            #input
        }
    }
}

fn generate_field_builder(
    p: &AttrParser,
    resource: &Ident,
    plural_resource: &Ident,
    f: &Field,
) -> TokenStream {
    let name = f.ident.as_ref().expect("Resource fields must be named");
    let meta = field_meta_name(name);
    if field_relation(p, resource, plural_resource, f).is_some() {
        quote! {
            // Relation fields are just placeholders indicating the type of the relation. The actual
            // contents of the relation will be loaded asynchronously, on-demand by the
            // corresponding resolver. Thus, we can just default-construct the placeholder.
            #name: Default::default(),
        }
    } else {
        quote! {
            #name: builder.field::<fields::#meta>().map_err(B::Error::field::<fields::#meta>)?,
        }
    }
}

fn generate_field_visitor(f: &Field) -> TokenStream {
    let name = f.ident.as_ref().expect("Resource fields must be named");
    let meta = field_meta_name(name);
    quote! {
        visitor.visit::<fields::#meta>()
    }
}

fn generate_relation_visitor(r: Relation) -> TokenStream {
    let name = r.name;
    let meta = field_meta_name(&name);
    match r.arity {
        RelationArity::ManyToMany => quote!(visitor.visit_many_to_many::<fields::#meta>()),
        RelationArity::ManyToOne => quote!(visitor.visit_many_to_one::<fields::#meta>()),
    }
}

fn generate_input_field(
    p: &AttrParser,
    resource: &Ident,
    plural_resource: &Ident,
    vis: &Visibility,
    f: &Field,
) -> Option<TokenStream> {
    if field_is_input(p, resource, plural_resource, f) {
        let ty = &f.ty;
        let Some(name) = &f.ident else {
            panic!("Resource fields must be named");
        };
        Some(quote! {
            #vis #name: <#ty as Type>::Input,
        })
    } else {
        None
    }
}

fn generate_predicate_field(
    p: &AttrParser,
    resource: &Ident,
    plural_resource: &Ident,
    f: &Field,
) -> TokenStream {
    let ty = &f.ty;
    let Some(name) = &f.ident else {
        panic!("Resource fields must be named");
    };
    if let Some(Relation { target, .. }) = field_relation(p, resource, plural_resource, f) {
        // If the field is a relation, it is filtered by a predicate on collections of the target
        // type.
        quote! {
            #name: Option<<#target as Resource>::RelationPredicate>,
        }
    } else {
        // Otherwise it is just filtered by the regular predicate.
        quote! {
            #name: Option<<#ty as Type>::Predicate>,
        }
    }
}

fn generate_has_builder_field(
    p: &AttrParser,
    resource: &Ident,
    plural_resource: &Ident,
    vis: &Visibility,
    f: &Field,
) -> TokenStream {
    let ty = &f.ty;
    let Some(name) = &f.ident else {
        panic!("Resource fields must be named");
    };
    let doc = format!("Apply a predicate to the field {name}.");
    if let Some(Relation { target, .. }) = field_relation(p, resource, plural_resource, f) {
        // If the field is a relation, it is filtered by a predicate on collections of the target
        // type.
        quote! {
            #[doc = #doc]
            #vis fn #name(
                mut self,
                pred: <#target as Resource>::RelationPredicate,
            ) -> Self {
                self.#name = Some(pred);
                self
            }
        }
    } else {
        // Otherwise it is just filtered by the regular predicate.
        quote! {
            #[doc = #doc]
            #vis fn #name(mut self, pred: <#ty as Type>::Predicate) -> Self {
                self.#name = Some(pred);
                self
            }
        }
    }
}

fn generate_resolver(
    p: &AttrParser,
    resource: &Ident,
    plural_resource: &Ident,
    f: &Field,
) -> TokenStream {
    let name = f.ident.as_ref().unwrap();
    let ty = &f.ty;
    let doc = parse_docs(&f.attrs);

    if let Some(Relation { target, .. }) = field_relation(p, resource, plural_resource, f) {
        let meta_name = field_meta_name(name);
        quote! {
            // Resolvers that yield collections get extra parameters for filtering the collections,
            // including paging parameters and a where clause.
            #[doc = #doc]
            async fn #name(
                &self,
                ctx: &Context<'_>,
                #[graphql(name = "where")]
                filter: Option<<#target as Type>::Predicate>,
                after: Option<String>,
                before: Option<String>,
                first: Option<i32>,
                last: Option<i32>,
            ) -> Result<Connection<Cursor<D, #target>, #target, EmptyFields, EmptyFields>> {
                // The field corresponding to this relation is just a placeholder for declaring the
                // type of the relation. Use it to silence dead code warnings.
                let _ = &self.#name;

                connection::query(after, before, first, last, |after, before, first, last| async move {
                    // Load the relation from the database.
                    let db = ctx.data::<D>()?;
                    let relation = db.load_relation::<fields::#meta_name>(self, filter).await?;

                    // Load the requested page.
                    let req = PageRequest { after, before, first, last };
                    let page = db.load_page(&relation, req).await?;

                    // Convert it into a GraphQL connection.
                    let has_previous = page
                        .first()
                        .map(|edge| relation.has_previous(edge.cursor()))
                        .unwrap_or(false);
                    let has_next = page
                        .last()
                        .map(|edge| relation.has_next(edge.cursor()))
                        .unwrap_or(false);
                    let mut conn = Connection::with_additional_fields(
                        has_previous,
                        has_next,
                        relation.into_fields(),
                    );
                    conn.edges.extend(page.into_iter().map(|edge| edge.into()));

                    Ok::<_, async_graphql::Error>(conn)
                }).await
            }
        }
    } else {
        quote! {
            // Regular fields just resolve to the field itself.
            #[doc = #doc]
            async fn #name(&self) -> &#ty {
                &self.#name
            }
        }
    }
}

fn field_is_id(p: &AttrParser, f: &Field) -> bool {
    // Check if the field is explicitly an ID.
    if p.has_bool(&f.attrs, "id") {
        return true;
    }

    // Check if the field has type `Id`.
    let Type::Path(path) = &f.ty else { return false; };
    let Some(type_name) = path.path.segments.last() else { return false; };
    type_name.ident == "Id"
}

fn field_relation(
    p: &AttrParser,
    resource: &Ident,
    plural_resource: &Ident,
    f: &Field,
) -> Option<Relation> {
    // The type of the field indicates the arity and target type of relation, if this is one (e.g.
    // `BelongsTo<Target>`).
    let Type::Path(path) = &f.ty else { return None; };
    let type_name = path.path.segments.last()?;

    // If this type is going to match, it must have a single generic argument which is the name of
    // the target resource.
    let PathArguments::AngleBracketed(target) = &type_name.arguments else { return None; };
    if target.args.len() != 1 {
        return None;
    }
    let GenericArgument::Type(Type::Path(target)) = target.args.first().unwrap() else {
        return None;
    };
    let target = target.path.get_ident()?.clone();

    // It must also have a name indicating the arity of the relation.
    let arity = if type_name.ident == "BelongsTo" {
        RelationArity::ManyToOne
    } else if type_name.ident == "Many" {
        RelationArity::ManyToMany
    } else {
        return None;
    };
    let inverse_name = match p.get_arg(&f.attrs, "inverse") {
        Some(inverse) => {
            // If the inverse is explicitly specified, take it and treat it as the name of the field
            // or relation on the target type which refers back to the owning type.
            field_meta_name(&inverse)
        }
        None => {
            // Otherwise, assume that the inverse is a field on the target type named for this type.
            // The pluralization is based on the arity.
            match arity {
                RelationArity::ManyToOne => resource.clone(),
                RelationArity::ManyToMany => plural_resource.clone(),
            }
        }
    };
    // The inverse is defined in the fields module of the target type.
    let target_mod = default_mod_name(&target);
    let inverse = syn::parse2(quote!(#target_mod::fields::#inverse_name)).unwrap();

    // The name comes from the field name.
    let name = f.ident.clone().unwrap();

    Some(Relation {
        arity,
        target,
        inverse,
        name,
    })
}

fn field_is_input(p: &AttrParser, resource: &Ident, plural_resource: &Ident, f: &Field) -> bool {
    // Relation fields are represented as the inverse of a relationship from some other resource; in
    // other words, they are not explicitly stored in this resource itself.
    //
    // The ID field is special in that it is auto-generated from an increasing sequence, so it is
    // not required (and, indeed, not allowed) when creating a resource.
    //
    // Thus, input fields are any that are neither relations nor ID.
    field_relation(p, resource, plural_resource, f).is_none() && !field_is_id(p, f)
}

fn skipped_field_default(p: &AttrParser, f: &Field) -> Option<TokenStream> {
    if p.has_bool(&f.attrs, "skip") {
        // The field is skipped with no explicit default. Use the [`Default`] trait.
        Some(quote!(Default::default()))
    } else {
        p.get_arg::<Expr, _>(&f.attrs, "skip").map(|default| {
            // The field is skipped and an explicit default expression is provided.
            quote!(#default)
        })
    }
}

fn field_meta_name(f: &Ident) -> Ident {
    Ident::new(&f.to_string().to_case(Case::Pascal), f.span())
}

fn default_mod_name(name: &Ident) -> Ident {
    Ident::new(&name.to_string().to_case(Case::Snake), Span::call_site())
}
